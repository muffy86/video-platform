import { Pinecone } from '@pinecone-database/pinecone';\nimport OpenAI from 'openai';\nimport { AgentType, ProjectData, AgentInteraction } from '../services/aiService';\n\ninterface ProjectMemory {\n  id: string;\n  description: string;\n  budget: number;\n  roomType: string;\n  style: string;\n  challenges: string[];\n  solutions: string[];\n  userSatisfaction: number;\n  actualTimeline: number;\n  materials: string[];\n  contractor?: string;\n  timestamp: number;\n}\n\ninterface SimilarProject {\n  similarity: number;\n  project: ProjectMemory;\n  insights: string[];\n  recommendations: string[];\n}\n\ninterface AgentLearning {\n  agentType: AgentType;\n  query: string;\n  response: string;\n  userFeedback: number;\n  effectiveness: number;\n  context: any;\n  timestamp: number;\n}\n\nclass AdvancedMemoryService {\n  private pinecone: Pinecone | null = null;\n  private openai: OpenAI;\n  private index: any = null;\n  private initialized = false;\n\n  constructor() {\n    this.openai = new OpenAI({\n      apiKey: process.env.REACT_APP_OPENAI_API_KEY || '',\n      dangerouslyAllowBrowser: true\n    });\n    \n    this.initializePinecone();\n  }\n\n  private async initializePinecone(): Promise<void> {\n    try {\n      const apiKey = process.env.REACT_APP_PINECONE_API_KEY;\n      if (!apiKey || apiKey.includes('your_')) {\n        console.log('Pinecone not configured - using local memory fallback');\n        return;\n      }\n\n      this.pinecone = new Pinecone({\n        apiKey: apiKey\n      });\n\n      const indexName = process.env.REACT_APP_PINECONE_INDEX || 'ai-remodeling-memory';\n      this.index = this.pinecone.index(indexName);\n      this.initialized = true;\n      \n      console.log('✅ Pinecone memory system initialized');\n    } catch (error) {\n      console.warn('Pinecone initialization failed, using fallback:', error);\n    }\n  }\n\n  async generateEmbedding(text: string): Promise<number[]> {\n    try {\n      const response = await this.openai.embeddings.create({\n        model: 'text-embedding-ada-002',\n        input: text\n      });\n      \n      return response.data[0].embedding;\n    } catch (error) {\n      console.error('Embedding generation failed:', error);\n      // Return dummy embedding for fallback\n      return new Array(1536).fill(0).map(() => Math.random() - 0.5);\n    }\n  }\n\n  async storeProjectMemory(project: ProjectData): Promise<void> {\n    if (!this.initialized || !this.index) {\n      // Store in localStorage as fallback\n      const localMemory = this.getLocalMemory('projects');\n      localMemory.push({\n        ...project,\n        timestamp: Date.now()\n      });\n      this.setLocalMemory('projects', localMemory);\n      return;\n    }\n\n    try {\n      const embedding = await this.generateEmbedding(\n        `${project.roomType} ${project.style} renovation: ${project.description} \n        Budget: ${project.budget} \n        Challenges: ${project.challenges?.join(', ')} \n        Solutions: ${project.solutions?.join(', ')}`\n      );\n\n      await this.index.upsert([{\n        id: `project-${project.id}-${Date.now()}`,\n        values: embedding,\n        metadata: {\n          type: 'project',\n          projectId: project.id,\n          budget: project.budget,\n          roomType: project.roomType,\n          style: project.style,\n          satisfaction: project.userSatisfaction || 5,\n          challenges: JSON.stringify(project.challenges || []),\n          solutions: JSON.stringify(project.solutions || []),\n          materials: JSON.stringify(project.materials || []),\n          contractor: project.contractor || '',\n          timestamp: Date.now()\n        }\n      }]);\n\n      console.log('✅ Project memory stored in Pinecone');\n    } catch (error) {\n      console.error('Failed to store project memory:', error);\n    }\n  }\n\n  async findSimilarProjects(\n    currentProject: { description: string; roomType: string; budget: number }\n  ): Promise<SimilarProject[]> {\n    if (!this.initialized || !this.index) {\n      // Use local memory fallback\n      return this.findSimilarProjectsLocal(currentProject);\n    }\n\n    try {\n      const queryEmbedding = await this.generateEmbedding(\n        `${currentProject.roomType} renovation: ${currentProject.description} Budget: ${currentProject.budget}`\n      );\n\n      const results = await this.index.query({\n        vector: queryEmbedding,\n        topK: 5,\n        includeMetadata: true,\n        filter: {\n          type: 'project',\n          roomType: currentProject.roomType\n        }\n      });\n\n      return results.matches.map((match: any) => ({\n        similarity: match.score,\n        project: this.parseProjectMetadata(match.metadata),\n        insights: this.extractInsights(match.metadata),\n        recommendations: this.generateRecommendations(match.metadata, currentProject)\n      }));\n    } catch (error) {\n      console.error('Failed to find similar projects:', error);\n      return [];\n    }\n  }\n\n  async storeAgentLearning(\n    agentType: AgentType,\n    interaction: AgentInteraction,\n    outcome: { userSatisfaction: number; effectiveness: number }\n  ): Promise<void> {\n    if (!this.initialized || !this.index) {\n      // Store in localStorage as fallback\n      const localLearning = this.getLocalMemory('agent_learning');\n      localLearning.push({\n        agentType,\n        ...interaction,\n        ...outcome,\n        timestamp: Date.now()\n      });\n      this.setLocalMemory('agent_learning', localLearning);\n      return;\n    }\n\n    try {\n      const embedding = await this.generateEmbedding(\n        `${agentType} agent: ${interaction.query} -> ${interaction.response}`\n      );\n\n      await this.index.upsert([{\n        id: `learning-${agentType}-${Date.now()}`,\n        values: embedding,\n        metadata: {\n          type: 'agent_learning',\n          agent: agentType,\n          query: interaction.query,\n          response: interaction.response,\n          userFeedback: outcome.userSatisfaction,\n          effectiveness: outcome.effectiveness,\n          context: JSON.stringify(interaction.context || {}),\n          timestamp: Date.now()\n        }\n      }]);\n\n      console.log(`✅ Agent learning stored for ${agentType}`);\n    } catch (error) {\n      console.error('Failed to store agent learning:', error);\n    }\n  }\n\n  async getAgentLearningHistory(agentType: AgentType): Promise<AgentLearning[]> {\n    if (!this.initialized || !this.index) {\n      // Use local memory fallback\n      const localLearning = this.getLocalMemory('agent_learning');\n      return localLearning.filter((item: any) => item.agentType === agentType);\n    }\n\n    try {\n      const results = await this.index.query({\n        vector: new Array(1536).fill(0), // Dummy vector for metadata-only search\n        topK: 20,\n        includeMetadata: true,\n        filter: {\n          type: 'agent_learning',\n          agent: agentType\n        }\n      });\n\n      return results.matches.map((match: any) => ({\n        agentType: match.metadata.agent,\n        query: match.metadata.query,\n        response: match.metadata.response,\n        userFeedback: match.metadata.userFeedback,\n        effectiveness: match.metadata.effectiveness,\n        context: JSON.parse(match.metadata.context || '{}'),\n        timestamp: match.metadata.timestamp\n      }));\n    } catch (error) {\n      console.error('Failed to get agent learning history:', error);\n      return [];\n    }\n  }\n\n  private findSimilarProjectsLocal(currentProject: any): SimilarProject[] {\n    const localProjects = this.getLocalMemory('projects');\n    \n    return localProjects\n      .filter((p: any) => p.roomType === currentProject.roomType)\n      .map((p: any) => ({\n        similarity: Math.random() * 0.3 + 0.7, // Simulate similarity\n        project: p,\n        insights: ['Similar budget range', 'Same room type'],\n        recommendations: ['Consider similar materials', 'Learn from previous challenges']\n      }))\n      .slice(0, 3);\n  }\n\n  private parseProjectMetadata(metadata: any): ProjectMemory {\n    return {\n      id: metadata.projectId,\n      description: 'Project from memory',\n      budget: metadata.budget,\n      roomType: metadata.roomType,\n      style: metadata.style,\n      challenges: JSON.parse(metadata.challenges || '[]'),\n      solutions: JSON.parse(metadata.solutions || '[]'),\n      userSatisfaction: metadata.satisfaction,\n      actualTimeline: metadata.timeline || 0,\n      materials: JSON.parse(metadata.materials || '[]'),\n      contractor: metadata.contractor,\n      timestamp: metadata.timestamp\n    };\n  }\n\n  private extractInsights(metadata: any): string[] {\n    const insights: string[] = [];\n    \n    if (metadata.satisfaction >= 4) {\n      insights.push('High user satisfaction achieved');\n    }\n    \n    if (metadata.budget) {\n      insights.push(`Budget was $${metadata.budget.toLocaleString()}`);\n    }\n    \n    if (metadata.challenges) {\n      const challenges = JSON.parse(metadata.challenges);\n      if (challenges.length > 0) {\n        insights.push(`Common challenges: ${challenges.slice(0, 2).join(', ')}`);\n      }\n    }\n    \n    return insights;\n  }\n\n  private generateRecommendations(metadata: any, currentProject: any): string[] {\n    const recommendations: string[] = [];\n    \n    if (metadata.solutions) {\n      const solutions = JSON.parse(metadata.solutions);\n      if (solutions.length > 0) {\n        recommendations.push(`Try proven solutions: ${solutions.slice(0, 2).join(', ')}`);\n      }\n    }\n    \n    if (metadata.materials) {\n      const materials = JSON.parse(metadata.materials);\n      if (materials.length > 0) {\n        recommendations.push(`Consider materials: ${materials.slice(0, 2).join(', ')}`);\n      }\n    }\n    \n    if (metadata.contractor && metadata.satisfaction >= 4) {\n      recommendations.push(`Successful contractor: ${metadata.contractor}`);\n    }\n    \n    return recommendations;\n  }\n\n  private getLocalMemory(key: string): any[] {\n    try {\n      const stored = localStorage.getItem(`ai_memory_${key}`);\n      return stored ? JSON.parse(stored) : [];\n    } catch {\n      return [];\n    }\n  }\n\n  private setLocalMemory(key: string, data: any[]): void {\n    try {\n      localStorage.setItem(`ai_memory_${key}`, JSON.stringify(data.slice(-50))); // Keep last 50\n    } catch (error) {\n      console.warn('Failed to store local memory:', error);\n    }\n  }\n\n  async clearMemory(): Promise<void> {\n    if (this.initialized && this.index) {\n      // In a real app, you'd implement proper cleanup\n      console.log('Memory cleared (Pinecone implementation needed)');\n    }\n    \n    // Clear local memory\n    localStorage.removeItem('ai_memory_projects');\n    localStorage.removeItem('ai_memory_agent_learning');\n  }\n\n  getMemoryStats(): { projects: number; learnings: number; provider: string } {\n    if (this.initialized) {\n      return {\n        projects: 0, // Would query Pinecone for actual count\n        learnings: 0,\n        provider: 'Pinecone'\n      };\n    } else {\n      const projects = this.getLocalMemory('projects').length;\n      const learnings = this.getLocalMemory('agent_learning').length;\n      return {\n        projects,\n        learnings,\n        provider: 'LocalStorage'\n      };\n    }\n  }\n}\n\nexport const advancedMemoryService = new AdvancedMemoryService();\nexport default advancedMemoryService;